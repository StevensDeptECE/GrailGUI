#include "curl/curl.h"
#include <stdio.h>
#include <string>
#include <stdexcept>
#include <fstream>
#define OTPLEN 44
#define IDLEN 12
#define KEYLEN 128

const char *YUBICO = "https://api.yubico.com";
const char *usage = "Usage: ./validateOtp <Yubikey generated OTP>";
const char *apikeypath = "./key.txt";

struct ValidateKeyRequest;
struct ValidateKeyResponse;

// makes an HTTP GET request to given URL, populates respnse
int makeRequest(const char *path, ValidateKeyResponse *response);
// takes request object and applies HMAC-SHA1, returning request
int HMACSign(ValidateKeyRequest *request, std::string *body, char* apikey);
// retrieves locally-stored Yubico client API key
int getApiKey(const char* path, char *keyBuf);

// Required fields: id, otp, nonce
typedef struct ValidateKeyRequest {
    // yubikey id
    std::string *id;
    // one-time-password generated by the yubikey
    std::string *otp;
    // HMAC-signature
    std::string *h;
    // timestamp (set to 1 to request session count in response)
    std::string *t;
    // random string of 16-40 chars
    std::string *nonce;
    // val 0-100 indicating percentage of syncing (leave empty for server to decide)
    std::string *sl;
    // seconds to wait for sync responses
    int timeout;
} ValidateKeyRequest;

typedef struct ValidateKeyResponse {
    std::string *otp;
    std::string *nonce;
    // signature in base64
    std::string *h;
    // UTC timestamp
    std::string *t;
    // result of validation
    std::string *status;
    // yubikey internal timestamp
    std::string *timestamp;
    // internal counter when key pressed
    std::string *sessioncounter;
    // intertnal session usage counter when key pressed
    std::string *sessionuse;
    int sl;
} ValidateKeyResponse;

/* *ValidateKeyResponse.status possible values
    OK                      - The OTP is valid.
    BAD_OTP                 - The OTP is invalid format.
    REPLAYED_OTP            - The OTP has already been seen by the service.
    BAD_SIGNATURE           - The HMAC signature verification failed.
    MISSING_PARAMETER       - The request lacks a parameter.
    NO_SUCH_CLIENT          - The request id does not exist.
    OPERATION_NOT_ALLOWED   - The request id is not allowed to verify OTPs.
    BACKEND_ERROR           - Unexpected error in our server. Please contact Yubico
                                if you see this error.
    NOT_ENOUGH_ANSWERS      - Server could not get requested number of syncs during before timeout
    REPLAYED_REQUEST        - Server has seen the OTP/Nonce combination before
 */

int main(int argc, char* argv[]) {

    std::string otp;
    std::string id;
    char idbuf[IDLEN];

    if (argc > 1) {
        otp = std::string(argv[1]);

        // attempt to set ID to first 12 chars of OTP
        try {        
            otp.copy(idbuf, IDLEN);
            id = std::string(idbuf);
        } catch (const std::out_of_range& oor) {
            fprintf(stderr, "Failed to retrieve ID from OTP: %s\n", oor.what());
            return -1;
        }        
    } else {
        printf("%s\n", usage);
        return 0;
    }

    char *apikey = (char *) malloc((size_t) KEYLEN);

    if (0 != getApiKey(apikeypath, apikey)) {
        fprintf(stderr, "Failed to read api key.\n");
        return -1;
    }

    printf("ID: %s\n"
        "OTP: %s\n"
        "API key: %s\n", id.c_str(), otp.c_str(), apikey);

    /**
     * TODO:
     *  - Construct ValidateKeyRequest struct
     *  - Pass object to HMACSign and take resulting URL
     *  - send HTTP GET to the url
     *  - take populated response and read it off to user
     */

    free(apikey);
    return 0;
}

/**
 *  TODO:
 *  - alphabetically sort key/val pairs
 *  - construct one string with all params concat'ed with & in between
 *  - apply HMAC-SHA1 on line as octet using (base64 DECODED) API key as key
 *  - base64 encode resulting value
 *  - return result 
 */
int HMACSign(ValidateKeyRequest req, std::string* body, char* apikey) {
    return 0;
}

/**
 * TODO:
 *  - http get given string
 *  - populate response struct 
 */
int makeRequest(const char* path, ValidateKeyResponse *response) {
    return 0;
}

int getApiKey(const char *path, char* keybuf) {
    
    std::ifstream keyfile;
    keyfile.open(path, std::ios::in);

    if (!keyfile.is_open()) {
        fprintf(stderr, "Failed to open key file\n");
        return -1;
    }

    char inbuf[128];
    keyfile.getline(inbuf, 127);
    inbuf[127] = '\0';

    try {
        // copy api key to passed buffed
        std::string(inbuf).copy(keybuf, 128);
    } catch (const std::out_of_range &oor) {
        fprintf(stderr, "Failed to get api key: %s\n", oor.what());
        return -1;
    }
    return 0;
}